import { LightDataExt } from './LightDataExt';
import { tokenInformations } from './tokenInformations';
import { canvas, game } from './settings';
import CONSTANTS from './constants';
import { error, log, warn } from './lib/lib';
import { LightHUDPreset, LightHUDPresetType } from './lights-hud-models';

class LightsHUD {
  // static clBanner() {
  //   const title =
  //     " _     _       _     _       _   _ _   _ ____   \n" +
  //     "| |   (_) __ _| |__ | |_ ___| | | | | | |  _ \\  \n" +
  //     "| |   | |/ _` | '_ \\| __/ __| |_| | | | | | | | \n" +
  //     "| |___| | (_| | | | | |_\\__ \\  _  | |_| | |_| | \n" +
  //     "|_____|_|\\__, |_| |_|\\__|___/_| |_|\\___/|____/  \n" +
  //     "         |___/                                 \n";
  //   console.log("%c" + title, "color:orange");
  // }

  static async addLightsHUDButtons(app, html, data) {
    const tokenInfoObject = app.object.data;
    const tokenInfo = new tokenInformations(tokenInfoObject);

    // Define all three buttons
    const tbuttonLight = $(
      `<div class="control-icon LightsHUD light" title="Toggle Light Spell"><i class="fas fa-sun"></i></div>`,
    );
    const tbuttonLantern = $(
      `<div class="control-icon LightsHUD lantern" title="Toggle Lantern"><i class="fas fa-lightbulb"></i></div>`,
    );
    const tbuttonTorch = $(
      `<div class="control-icon LightsHUD torch" title="Toggle Torch"><i class="fas fa-fire"></i></div>`,
    );

    // Get the position of the column
    const position = game.settings.get(CONSTANTS.MODULE_NAME, 'position');

    // Create the column
    const buttonsdiv = $(`<div class="col LightsHUD-column-${position}"></div>`);

    // Wrap the previous icons
    const newdiv = '<div class="LightsHUD-container"></div>';
    html.find('.col.left').before(newdiv);

    // Add the column
    html.find('.LightsHUD-container').prepend(buttonsdiv);

    // Get the status of the three types of lights

    const spellLight = new LightDataExt(LightHUDPreset.LIGHT, LightHUDPresetType.SPELL, false, app);
    const lanternLight = new LightDataExt(LightHUDPreset.LANTERN, LightHUDPresetType.CONSUMABLE, false, app);
    const torchLight = new LightDataExt(LightHUDPreset.TORCH, LightHUDPresetType.CONSUMABLE, false, app);

    const tokenD = app.object.document;

    // const hasInventoryCheck = game.settings.get(CONSTANTS.MODULE_NAME, 'checkAvailability');
    // const consumptionCheck = game.settings.get(CONSTANTS.MODULE_NAME, 'consumeItem');

    // Initial button state when the HUD comes up
    if (spellLight.state) tbuttonLight.addClass('active');
    if (lanternLight.state) tbuttonLantern.addClass('active');
    if (torchLight.state) tbuttonTorch.addClass('active');
    // Check the permissions to manage the lights

    if (!data.isGM && !game.settings.get(CONSTANTS.MODULE_NAME, 'playerActivation')) {
      disableLightsHUDButton(tbuttonLight);
      disableLightsHUDButton(tbuttonLantern);
      disableLightsHUDButton(tbuttonTorch);
      return;
    }
    // If the a specific light is on, enable only that light otherwise enable all three of them
    if (spellLight.state) {
      enableLightsHUDButton(tbuttonLight);
      disableLightsHUDButton(tbuttonLantern);
      disableLightsHUDButton(tbuttonTorch);
    } else if (lanternLight.state) {
      disableLightsHUDButton(tbuttonLight);
      enableLightsHUDButton(tbuttonLantern);
      disableLightsHUDButton(tbuttonTorch);
    } else if (torchLight.state) {
      disableLightsHUDButton(tbuttonLight);
      disableLightsHUDButton(tbuttonLantern);
      enableLightsHUDButton(tbuttonTorch);
    } else enableButtonsPerSettings();

    // Returns true if the character can use the Light spell
    // This also returns true if the game system is not D&D 5e...
    function canCastLight() {
      const actor = game.actors?.get(data.actorId);
      if (actor === undefined) return false;
      let hasLight = false;
      actor.data.items.forEach((item) => {
        if (item.type === 'spell') {
          if (item.name === 'Light') hasLight = true;
        }
      });
      return hasLight;
    }

    // Returns true if the character has a specific item in his inventory
    // This also returns true if the game system is not D&D 5e...
    function hasItem(itemToCheck) {
      let consumables;

      if (game.system.id === 'dnd5e') {
        consumables = tokenInfo.itemList.filter(
          (item) =>
            (item.type === LightHUDPresetType.CONSUMABLE &&
              item.name.toLowerCase() === itemToCheck.toLowerCase() &&
              item.data.quantity > 0) ??
            false,
        );
      }
      if (game.system.id === 'pf2e') {
        consumables = tokenInfo.itemList.filter(
          (item) =>
            (item.type === LightHUDPresetType.CONSUMABLE &&
              item.name.toLowerCase() === itemToCheck.toLowerCase() &&
              item.data.quantity.value > 0) ??
            false,
        );
      }
      if (!consumables) return false;

      return consumables.length > 0 ? consumables : false;
    }

    // async function consumeItem(item) {
    //   if (!item) return;
    //   try {
    //     const itemID = item[0]._id;
    //     let newQte;
    //     if (game.system.id === 'dnd5e') {
    //       newQte = item[0].data.quantity - 1;
    //       if (tokenInfo.getLinked()) {
    //         await game.actors
    //           ?.get(tokenInfo.getActorID())
    //           ?.updateEmbeddedDocuments('Item', [{ _id: itemID, 'data.quantity': newQte }]);
    //       } else {
    //         await game.actors?.tokens[tokenInfo.getTokenID()]?.updateEmbeddedDocuments('Item', [
    //           { _id: itemID, 'data.quantity': newQte },
    //         ]);
    //       }
    //     }
    //     if (game.system.id === 'pf2e') {
    //       newQte = item[0].data.quantity.value - 1;
    //       if (tokenInfo.getLinked()) {
    //         await game.actors
    //           ?.get(tokenInfo.getActorID())
    //           ?.updateEmbeddedDocuments('Item', [{ _id: itemID, 'data.quantity.value': newQte }]);
    //       } else {
    //         await game.actors?.tokens[tokenInfo.getTokenID()]?.updateEmbeddedDocuments('Item', [
    //           { _id: itemID, 'data.quantity.value': newQte },
    //         ]);
    //       }
    //     } else {
    //       warn(`Current system '${game.system.id}' is not supported for the consume item feature`, true);
    //     }
    //     return true;
    //   } catch (err) {
    //     error('Error during consumption:');
    //     error(err);
    //     return false;
    //   }
    // }

    function enableLightsHUDButton(tbutton) {
      // Remove the disabled status, if any
      tbutton.find('i').removeClass('fa-disabled');
      tbutton.addClass('active');
      // Install a click handler if one is not already bound
      if (!tbutton.hasClass('clickBound')) {
        tbutton.click(async (ev) => onButtonClick(ev, tbutton));
        tbutton.addClass('clickBound');
      }
    }
    // Visually and functionally disable a LightsHUD button
    function disableLightsHUDButton(tbutton) {
      tbutton.find('i').addClass('fa-disabled');
      tbutton.off('click');
      tbutton.removeClass('clickBound');
      tbutton.removeClass('active');
    }

    // Enable or disable buttons according to parameters
    function enableButtonsPerSettings() {
      const checkAvailability = <boolean>game.settings.get(CONSTANTS.MODULE_NAME, 'checkAvailability');
      const lantern = (<string>(
        game.settings.get(CONSTANTS.MODULE_NAME, 'lanternType.nameConsumableLantern')
      )).toLowerCase();
      const torch = (<string>game.settings.get(CONSTANTS.MODULE_NAME, 'torchType.nameConsumableTorch')).toLowerCase();

      let noCheck; // = game.system.id !== "dnd5e";
      if (!noCheck) noCheck = !checkAvailability;

      if (noCheck || canCastLight()) {
        enableLightsHUDButton(tbuttonLight);
      } else {
        disableLightsHUDButton(tbuttonLight);
      }

      if (noCheck || hasItem(lantern)) {
        enableLightsHUDButton(tbuttonLantern);
      } else {
        disableLightsHUDButton(tbuttonLantern);
      }

      if (noCheck || hasItem(torch)) {
        enableLightsHUDButton(tbuttonTorch);
      } else {
        disableLightsHUDButton(tbuttonTorch);
      }
    }

    async function onButtonClick(ev, tbutton) {
      ev.preventDefault();
      ev.stopPropagation();
      log('On Button Click');

      // Are we dealing with the Light Button
      if (tbutton.hasClass(LightHUDPreset.LIGHT)) {
        // Check if the token has the light spell on
        if (spellLight.state) {
          // The token has the light spell on
          spellLight.state = false;
          // await tokenD.setFlag(CONSTANTS.MODULE_NAME, spellLight._getFlagName(), false);
          tbuttonLight.removeClass('active');
          // Light is inactive, enable the relevant light sources according to parameters
          enableButtonsPerSettings();

          // Restore the initial light source
          // updateTokenLighting(
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialBrightRadius'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialDimRadius'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialLightColor'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialColorIntensity'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'Initiallight.angle'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationType'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationSpeed'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationIntensity'),
          // );
        } else {
          // The token does not have the light spell on
          spellLight.state = true;
          // await tokenD.setFlag(CONSTANTS.MODULE_NAME, spellLight._getFlagName(), true);
          tbuttonLight.addClass('active');
          // Light is active, disable the other light sources
          disableLightsHUDButton(tbuttonLantern);
          disableLightsHUDButton(tbuttonTorch);
          // Store the lighting for later restoration
          await storeTokenLighting();
          // Enable the Light Source according to the type
          // "torch" / "pulse" / "chroma" / "wave" / "fog" / "sunburst" / "dome"
          // "emanation" / "hexa" / "ghost" / "energy" / "roiling" / "hole"
          const nBright = game.settings.get(CONSTANTS.MODULE_NAME, 'lightBrightRadius');
          const nDim = game.settings.get(CONSTANTS.MODULE_NAME, 'lightDimRadius');
          const nType = game.settings.get(CONSTANTS.MODULE_NAME, 'lightType');
          switch (nType) {
            case 'Type0':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'none', 5, 5);
              break;
            case 'Type1':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type2':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type3':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type4':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type5':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'Type6':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type7':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type8':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type9':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type10':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'Type11':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type12':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type13':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type14':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type15':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'TypeC':
              updateTokenLighting(
                nBright,
                nDim,
                game.settings.get(CONSTANTS.MODULE_NAME, 'customLightColor'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customLightColorIntensity'),
                360,
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationType'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationSpeed'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationIntensity'),
              );
              break;
          }
        }
      }
      if (tbutton.hasClass(LightHUDPreset.LANTERN)) {
        const consumable =
          (<string>game.settings.get(CONSTANTS.MODULE_NAME, 'lanternType.nameConsumableLantern')).toLowerCase() ??
          false;
        const hasItemNow = hasItem(consumable);

        // Check if the token has the light spell on
        if (lanternLight.state) {
          // The token has the light spell on
          lanternLight.state = false;
          // await tokenD.setFlag(CONSTANTS.MODULE_NAME, lanternLight._getFlagName(), false);
          // Light is inactive, enable the relevant light sources according to parameters
          enableButtonsPerSettings();
          // Restore the initial light source
          // updateTokenLighting(
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialBrightRadius'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialDimRadius'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialLightColor'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialColorIntensity'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'Initiallight.angle'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationType'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationSpeed'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationIntensity'),
          // );
          return;
        }
        // if (!lanternLight.state && hasInventoryCheck && !hasItemNow) return;
        // if (!lanternLight.state && consumptionCheck && !consumeItem(hasItemNow)) return;
        if (!lanternLight.state) {
          disableLightsHUDButton(tbuttonTorch);
          disableLightsHUDButton(tbuttonLight);
          lanternLight.state = true;
          // await tokenD.setFlag(CONSTANTS.MODULE_NAME, lanternLight._getFlagName(), true);

          // Store the lighting for later restoration
          await storeTokenLighting();
          // Enable the Light Source according to the type
          // "torch" / "pulse" / "chroma" / "wave" / "fog" / "sunburst" / "dome"
          // "emanation" / "hexa" / "ghost" / "energy" / "roiling" / "hole"
          const nBright = game.settings.get(CONSTANTS.MODULE_NAME, 'lanternBrightRadius');
          const nDim = game.settings.get(CONSTANTS.MODULE_NAME, 'lanternDimRadius');
          const nType = game.settings.get(CONSTANTS.MODULE_NAME, 'lanternType');
          switch (nType) {
            case 'Type0':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'none', 5, 5);
              break;
            case 'Type1':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type2':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type3':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type4':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type5':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'Type6':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type7':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type8':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type9':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type10':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'Type11':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type12':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type13':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type14':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type15':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'TypeC':
              updateTokenLighting(
                nBright,
                nDim,
                game.settings.get(CONSTANTS.MODULE_NAME, 'customLightColor'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customLightColorIntensity'),
                360,
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationType'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationSpeed'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationIntensity'),
              );
              break;
          }
        }
      }
      if (tbutton.hasClass(LightHUDPreset.TORCH)) {
        const consumable = (<string>game.settings.get(CONSTANTS.MODULE_NAME, 'torchType.nameConsumableTorch')).toLowerCase()
          ? true : false;
        const hasItemNow = hasItem(consumable);

        // Check if the token has the light spell on
        if (torchLight.state) {
          // The token has the light spell on
          torchLight.state = false;
          // await tokenD.setFlag(CONSTANTS.MODULE_NAME, torchLight._getFlagName(), false);
          // Light is inactive, enable the relevant light sources according to parameters
          enableButtonsPerSettings();
          // Restore the initial light source
          // updateTokenLighting(
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialBrightRadius'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialDimRadius'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialLightColor'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialColorIntensity'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'Initiallight.angle'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationType'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationSpeed'),
          //   tokenD.getFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationIntensity'),
          // );
          return;
        }
        // if (!torchLight.state && hasInventoryCheck && !hasItemNow) return;
        // if (!torchLight.state && consumptionCheck && !consumeItem(hasItemNow)) return;
        if (!torchLight.state) {
          disableLightsHUDButton(tbuttonLantern);
          disableLightsHUDButton(tbuttonLight);
          torchLight.state = true;
          // await tokenD.setFlag(CONSTANTS.MODULE_NAME, torchLight._getFlagName(), true);

          // Store the lighting for later restoration
          await storeTokenLighting();
          // Enable the Light Source according to the type
          // "torch" / "pulse" / "chroma" / "wave" / "fog" / "sunburst" / "dome"
          // "emanation" / "hexa" / "ghost" / "energy" / "roiling" / "hole"
          const nBright = game.settings.get(CONSTANTS.MODULE_NAME, 'torchBrightRadius');
          const nDim = game.settings.get(CONSTANTS.MODULE_NAME, 'torchDimRadius');
          const nType = game.settings.get(CONSTANTS.MODULE_NAME, 'torchType');
          switch (nType) {
            case 'Type0':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'none', 5, 5);
              break;
            case 'Type1':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type2':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type3':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type4':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type5':
              updateTokenLighting(nBright, nDim, '#ffffff', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'Type6':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type7':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type8':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type9':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type10':
              updateTokenLighting(nBright, nDim, '#ff0000', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'Type11':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'torch', 5, 5);
              break;
            case 'Type12':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'chroma', 5, 5);
              break;
            case 'Type13':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'pulse', 5, 5);
              break;
            case 'Type14':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'ghost', 5, 5);
              break;
            case 'Type15':
              updateTokenLighting(nBright, nDim, '#00ff00', 0.5, 360, 'emanation', 5, 5);
              break;
            case 'TypeC':
              updateTokenLighting(
                nBright,
                nDim,
                game.settings.get(CONSTANTS.MODULE_NAME, 'customLightColor'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customLightColorIntensity'),
                360,
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationType'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationSpeed'),
                game.settings.get(CONSTANTS.MODULE_NAME, 'customlight.animationIntensity'),
              );
              break;
          }
        }
      }
    }

    // Update the relevant light parameters of a token
    function updateTokenLighting(
      bright,
      dim,
      lightColor,
      colorIntensity,
      angle,
      animationType,
      animationSpeed,
      animationIntensity,
    ) {
      app.object.document.update({
        light: {
          bright: bright,
          dim: dim,
          alpha: colorIntensity ** 2,
          color: lightColor,
          angle: angle,
          animation: {
            type: animationType,
            speed: animationSpeed,
            intensity: animationIntensity,
          },
        },
      });
    }
    // Store the initial status of illumination for the token to restore if all light sources are extinguished
    async function storeTokenLighting() {
      const promises: any[] = [];
      const tokenData = app.object.data;
      const tokenFlags = app.object.document;
      promises.push(tokenFlags.setFlag(CONSTANTS.MODULE_NAME, 'InitialBrightRadius', tokenData.light.bright));
      promises.push(tokenFlags.setFlag(CONSTANTS.MODULE_NAME, 'InitialDimRadius', tokenData.light.dim));
      promises.push(
        tokenFlags.setFlag(
          CONSTANTS.MODULE_NAME,
          'InitialLightColor',
          tokenData.lightColor ? tokenData.lightColor.toString(16).padStart(6, 0) : null,
        ),
      );
      promises.push(
        tokenFlags.setFlag(CONSTANTS.MODULE_NAME, 'InitialColorIntensity', Math.sqrt(tokenData.lightAlpha)),
      );
      promises.push(tokenFlags.setFlag(CONSTANTS.MODULE_NAME, 'Initiallight.angle', tokenData.light.angle));
      promises.push(
        tokenFlags.setFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationType', tokenData.light.animation.type ?? null),
      );
      promises.push(
        tokenFlags.setFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationSpeed', tokenData.light.animation.speed),
      );
      promises.push(
        tokenFlags.setFlag(CONSTANTS.MODULE_NAME, 'InitialAnimationIntensity', tokenData.light.animation.intensity),
      );

      return Promise.all(promises);
    }

    async function sendRequest(req) {
      req.sceneId = canvas.scene._id;
      req.tokenId = app.object.id;

      if (!data.isGM) {
        req.addressTo = firstGM();
        game.socket.emit('module.torch', req);
      } else {
        LightsHUD.handleSocketRequest(req);
      }
    }

    // Finally insert the buttons in the column
    html.find('.col.LightsHUD-column-' + position).prepend(tbuttonTorch);
    html.find('.col.LightsHUD-column-' + position).prepend(tbuttonLantern);
    html.find('.col.LightsHUD-column-' + position).prepend(tbuttonLight);
  }

  // static log(data) {
  //   if (this.debug()) console.log("LightsHUD | ", data);
  // }

  // static async handleSocketRequest(req) {
  //   if (req.addressTo === undefined || req.addressTo === game.user?.id) {
  //     const scn = <Scene>game.scenes?.get(req.sceneId);
  //     const tkn = <TokenDocument>scn.data.tokens.find((token) => token.id === req.tokenId);
  //     const dltoks: TokenDocument[] = [];

  //     switch (req.requestType) {
  //       case 'removeDancingLights': {
  //         scn.data.tokens.forEach((tok: TokenDocument) => {
  //           if (
  //             tok.actor?.id === tkn.actor?.id &&
  //             tok.name === 'Dancing Light' &&
  //             tok.data.dimLight === 20 &&
  //             tok.data.brightLight === 10
  //           ) {
  //             dltoks.push(<TokenDocument>scn.getEmbeddedDocument('Token', <string>tok.id));
  //           }
  //         });
  //         const tokenIds = dltoks.map((e: TokenDocument) => {
  //           return e.object ? <string>e.object?.id : <string>e.id;
  //         });
  //         await scn.deleteEmbeddedDocuments('Token', tokenIds);
  //         break;
  //       }
  //     }
  //   }
  // }

  // static debug() {
  //   let isDebug = game.settings.get(CONSTANTS.MODULE_NAME, "debug");
  //   if (isDebug) CONFIG.debug.hooks = false;
  //   if (!isDebug) CONFIG.debug.hooks = false;

  //   return isDebug;
  // }
}
